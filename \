import numpy as np
import argparse
import json
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D

# atom struct
atom_dtype = np.dtype([
	('r', 'f8', (3,)),
	('m', 'f8'),
	('elem', 'U2')
])

# bond struct
bond_dtype = np.dtype([
	('a1', int),
	('a2', int),
	('R', int, (2,)),
	('l', 'f8'),
	('d', 'f8', (3,)),
	('k', 'f8')
])
# Atom colors
atom_colors = {'H' : 'blue',
		'C' : 'black'
}

# Arg parser
parser = argparse.ArgumentParser()
parser.add_argument('-f', '--filepath')

args = parser.parse_args()

def RotationMatrix(theta):
        return np.array([[np.cos(theta), np.sin(theta), 0],
                        [-np.sin(theta), np.cos(theta), 0],
                        [0, 0, 1]])


### ONLY WORKS FOR SQUARE LATTICE
def GenerateMoireParams(legx, legy, h):
	"""
	Create a Moire pattern based on the given legx and legy values.
	Parameters:
	legx (int): x leg of Moire pattern.
	legy (int): y leg of Moire pattern.
	Returns:
	tuple: Contains twist angle, bottom, top, and Moire lattice vectors.
	"""

	# Check if the Moire pattern is commensurate
	if (int(np.sqrt(legx**2 + legy**2)) != np.sqrt(legx**2 + legy**2)):
		print("Warning: Moire pattern is not commensurate")


        # Twist Angle   
	theta = np.atan(legx/legy)
	R = RotationMatrix(theta)

        # Bottom lattice vectors
	ebx = np.array([1, 0, 0]);
	eby = np.array([0, 1, 0]);


        # Top lattice vectors
	etx = np.dot(R, ebx)
	ety = np.dot(R, eby)

        # Moire Lattice Vectors 
	eMx = np.sqrt(legx**2 + legy**2) * etx;
	eMy = np.sqrt(legx**2 + legy**2) * ety;

	# Moire inverse lattice vectors
	GMx = 2 * np.pi * RotationMatrix(np.pi/2) @ eMy / (eMx @ RotationMatrix(np.pi/2) @ eMy)
	GMy = 2 * np.pi * RotationMatrix(np.pi/2) @ eMx / (eMy @ RotationMatrix(np.pi/2) @ eMx)


	return theta, h, ebx, eby, etx, ety, eMx, eMy, GMx, GMy



def LoadParamsFromJSON(filepath):
	with open(filepath, 'r') as file:
		data = json.load(file)
	
	return data
def GenerateMomentumLoop(q_points, segment_n):
	q_loop = []
	for i in range(len(q_points)):
		start = np.array(q_points[i])
		end = np.array(q_points[(i+1) % len(q_points)])
	
		for j in range(segment_n):
			q_loop.append(start + j * (end-start)/segment_n)
	return q_loop

def GenerateMoireUnitCell(unit_cell, moire_params, delta = .01):
	"""
	unit_cell : specified as list of [x,y,z,m] for each atom
	moire_params : twist, height, lattice vectors (top, bottom, moire)
	"""
	# Unpack params
	twist, h, ebx, eby, etx, ety, eMx, eMy = moire_params
		
	bottom_unit_cell = unit_cell
	top_unit_cell = np.array([(RotationMatrix(twist) @ a['r'], a['m'], a['elem']) for a in unit_cell], dtype=atom_dtype)

	n = int(eMx@eMx + 1)
	
	moire_unit_cell = []
	
	for i in range(-n, n, 1):
		for j in range(-n, n, 1):
			# Bottom layer
			r = i * ebx + j * eby
			# If within moire lattice vectoprs
			if r @ eMx / (eMx @ eMx) <= 1-delta and r @ eMx / (eMx @ eMx) > -delta and r @ eMy / (eMy @ eMy) <= 1-delta and r @ eMy / (eMy @ eMy) > -delta:
				# For atom
				for a in bottom_unit_cell:
					moire_unit_cell.append((a['r'] + r, a['m'], a['elem']))
			# Top layer
			r = i * etx + j * ety
			# If within moire
			if r @ eMx / (eMx @ eMx) <= 1-delta and r @ eMx / (eMx @ eMx) > -delta and r @ eMy / (eMy @ eMy) <= 1-delta and r @ eMy / (eMy @ eMy) > -delta:
				# For atom in top unit cell
				for a in top_unit_cell:
					moire_unit_cell.append((a['r'] + r + np.array([0,0,h]), a['m'], a['elem']))
				
	return np.array(moire_unit_cell, dtype = atom_dtype)

def PlotUnitCell(unit_cell):
	fig = plt.figure()
	
	ax = fig.add_subplot(111,projection='3d')

	for atom in unit_cell:
		ax.scatter(atom['r'][0], atom['r'][1], atom['r'][2], color = atom_colors[atom['elem']])			


	plt.show()


def CreateBonds(unit_cell, neighboring_unit_cells, lattice_x, lattice_y, d_cutoff = np.sqrt(2), inter_layer = 1, intra_layer = 1):
	bonds = []
	for a1 in range(len(unit_cell)):
		for a2 in range(len(unit_cell)):
			for R in neighboring_unit_cells:
				vec = unit_cell[a2]['r'] + lattice_x * R[0] + lattice_y * R[1] - unit_cell[a1]['r']
				if np.linalg.norm(vec) <= d_cutoff and np.linalg.norm(vec) != 0:
					# Inter layer
					if vec[2] > .1:
						bonds.append(
							(a1, # Atom 1 index
							 a2, # Atom 2 index
							 R, # Unit Cell index
							 np.linalg.norm(vec), # length of bond
							 vec/np.linalg.norm(vec), # Direction of bond
							 np.exp(-inter_layer * np.linalg.norm(vec)) # Strength of bond
							)
						)
					# Intra layer
					else:
						bonds.append(
							(a1, # Atom 1 index
							 a2, # Atom 2 index
							 R, # Unit Cell index
							 np.linalg.norm(vec), # length of bond
							 vec/np.linalg.norm(vec), # Direction of bond
							 np.exp(-intra_layer * np.linalg.norm(vec))) # Strength of bond
						)

	return bonds

def PlotBonds(bonds, unit_cell, lattice_x, lattice_y):
	fig = plt.figure()
	ax = fig.add_subplot(111, projection = '3d')
	for bond in bonds:
		x1 = unit_cell[bond[0]]['r'][0] # X Position of atom 1
		y1 = unit_cell[bond[0]]['r'][1] # Y position of atom 1
		z1 = unit_cell[bond[0]]['r'][2] # Z position of atom 1
		x2 = unit_cell[bond[1]]['r'][0] # X Position of atom 2
		y2 = unit_cell[bond[1]]['r'][1] # Y Position of atom 2
		z2 = unit_cell[bond[1]]['r'][2] # Z position of atom 2
		R = bond[2][0] * lattice_x + bond[2][1] * lattice_y
		
		ax.plot3D([x1, x2 + R[0]], [y1, y2 + R[1]], [z1, z2 + R[2]], color = 'black')
		
	plt.show()


def DynamicsMatrix(bonds, unit_cell, lattice_x, lattice_y, q):
	dynamics_matrix = np.zeros((3 * len(unit_cell), 3* len(unit_cell)), dtype = complex)

	for bond in bonds:
		a1 = bond[0]
		a2 = bond[1]
		R = bond[2]
		l = bond[3]
		vec = bond[4]
		d3x3 = bond[5] * np.outer(vec,vec)
	
		# Only grabbing z component
		#d3x3 = bond[5]  * np.array([[0,0,0],[0,0,0],[0,0,vec[2]*vec[2]]])
		m = unit_cell[a1]['m']
	
		dynamics_matrix[3*a1:3*a1+3, 3*a2:3*a2+3] -= d3x3 * np.exp(1j * np.dot(q, R[0] * lattice_x + R[1] * lattice_y))/m # Off diagonal
		dynamics_matrix[3*a1:3*a1+3, 3*a1:3*a1+3] += d3x3/m # Diagonal
	return dynamics_matrix

def PlotBandStructure(bands):

	fig, ax = plt.subplots()
	bands = np.real(np.array(bands))
	
	for i in range(len(bands[0])):
		ax.plot(bands[:, i], linestyle = '', marker='.', color = 'black')
	plt.show()
	

def main():
	# Get Moire Params
	twist, height, ebx, eby, etx, ety, eMx, eMy, GMx, GMy = GenerateMoireParams(0, 1, 1)
	
	# Create Moire Unit Cell
	moire_unit_cell = GenerateMoireUnitCell(np.array([
						((0.0, 0.0, 0.0), 1.0,'H')],
						 dtype = atom_dtype),
						(twist, height, ebx, eby, etx, ety, eMx, eMy))
	# Create Momentum Loop
	segment_n = 20
	q_loop = GenerateMomentumLoop([
					np.array([0,0,0]),
					np.pi * eMx / (eMx @ eMx),
					np.pi * eMx / (eMx @ eMx) + np.pi * eMy / (eMy @ eMy)],
					 segment_n)	
	print(len(moire_unit_cell))	
	# Set Neighboring unit cells
	neighboring_unit_cells = [
		[-2,-2, 0],
		[-2, -1,0],
		[-2,0,0],
		[-2,1,0],
		[-2,2,0],
		[-1, -2, 0],
		[-1, -1, 0],
		[-1, 0, 0],
		[-1, 1, 0],
		[-1, 2, 0],
		[0, -2, 0],
		[0, -1, 0],
		[0, 0, 0],
		[0, 1, 0],
		[0, 2, 0],
		[1, -2, 0],
		[1, -1, 0],
		[1, 0, 0],
		[1, 1, 0],
		[1, 2, 0],
		[2, -2, 0],
		[2, -1, 0],
		[2, 0, 0],
		[2, 1, 0],
		[2, 2, 0]
	]	

	# Create Plot
	fig = plt.figure(figsize = (2,10))
	ax = fig.add_subplot(111)
	
	# Loop over bond distance cutoffs
	inter_layer_dom = [0, 1, 2, 3, 4, 5]

	custom_lines = [Line2D([0], [0], color=(l/np.max(inter_layer_dom),0,1-l/np.max(inter_layer_dom)), lw=4) for l in inter_layer_dom]
	
	ax.legend(custom_lines, [r'$\lambda$='+str(l) for l in inter_layer_dom])
	for inter in inter_layer_dom:
		bonds = CreateBonds(moire_unit_cell, neighboring_unit_cells, eMx, eMy, d_cutoff = 9, inter_layer = inter)
		#PlotBonds(bonds, moire_unit_cell, eMx, eMy)
		print(inter)
		bands = []
	
		for q in q_loop:
			dm = DynamicsMatrix(bonds, moire_unit_cell, eMx, eMy, q)

			vals, vecs = np.linalg.eig(dm)
			bands.append(np.sqrt(vals))
			
		bands = np.real(np.array(bands))
		for i in range(len(bands[0])):
			ax.plot(bands[:,i], linestyle = '', marker = '.', color = (inter/np.max(inter_layer_dom), 0, 1 - inter/np.max(inter_layer_dom)))

	
	plt.show()
				
if __name__ == "__main__":
	main()
